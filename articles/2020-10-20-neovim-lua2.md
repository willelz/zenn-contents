---
title: "Neovimã®ãŸã‚ã®Luaå…¥é–€"
emoji: "ğŸ‘"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Neovim","Lua"]
published: false
---

## ã¯ã˜ã‚ã«
ä»Šå›ã¯`Lua.txt`ã‚’è¦‹ã¦ã„ãã¾ã™

## ã©ã†ã‚„ã£ã¦èª­ã¿è¾¼ã‚€ã®ã‹
å‰å›ã¯ãƒãƒƒãƒ•ã‚¡ã‚„ã‚³ãƒãƒ³ãƒ‰ãƒ©ãƒ³ãƒ¢ãƒ¼ãƒ‰ã‹ã‚‰Luaã‚’ç›´æ¥å®Ÿè¡Œã—ã¦ã„ã¾ã—ãŸã€‚
`runtimepath`å†…ã®`lua`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç½®ãã¨ã€Luaã®`require`ã‹ã‚‰èª­ã¿è¾¼ã‚ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
`plugin/hoge.vim`ç­‰ã®`.vim`ãƒ•ã‚¡ã‚¤ãƒ«ã¨é•ã„ã€ãƒ‘ã‚¹ãŒé€šã‚‹ã ã‘ã§è‡ªå‹•ã§èª­ã¿è¾¼ã¾ã‚Œã¾ã›ã‚“ã€‚
ãã®ãŸã‚ã€`init.vim`ç­‰ã®ã©ã“ã‹ã—ã‚‰ã§Luaã‚’å‘¼ã¶å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```lua
-- lua/hi.lua

local hi = {}                                                                                                         
hi.str = 'hi'                                                                                                         
return hi

--

:lua print(require('hi").str)
"hi
```

`lua/hello/init.lua`ã®ã‚ˆã†ã«ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œã‚‹ã¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã§`require`ã§ãã¾ã™ã€‚
ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’ä½œã‚‹å ´åˆã¯ã“ã¡ã‚‰ãŒä¸€èˆ¬çš„ã§ã™ã€‚

```lua
-- lua/hello/init.lua

local hello = {}
hello.str = 'hello'

return hello

--

:lua print(require('hello').str) 
"hello
```

## Luaãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä¾‹
`:h lua-require-example`ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä¾‹ã‚’è¦‹ã¦ã¿ã¾ã™ã€‚
`~/.config/nvim`å†…ç­‰ã®ãƒ‘ã‚¹ã®é€šã£ãŸã¨ã“ã‚ã«é…ç½®ã™ã‚‹ã¨æ‰‹å…ƒã§å‹•ã‹ã™ã“ã¨ãŒã§ãã¾ã™ã€‚

charblob.luaã¯Luaã§å®Œçµã—ã¦ã„ã‚‹ã®ã§å‚è€ƒã¾ã§ã«ã€æ³¨ç›®ã—ã¦æ¬²ã—ã„ã®ã¯charblob.vimã§ã™ã€‚
ã“ã®ä¾‹ã§ã¯æ™®é€šã®vimãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ã‚ˆã†ã«Vim scriptã‹ã‚‰Luaã®é–¢æ•°ã‚’å‘¼ã¶å½¢ã«ãªã£ã¦ã„ã¾ã™ã€‚
é–¢æ•°ã®æä¾›æ–¹æ³•ã‚’å·¥å¤«ã™ã‚Œã°autoloadã‚„pluginãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¯å¿…é ˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã—ã‹ã—ã€Luaã Luaã ã¨è¨€ã£ã¦ã‚‚åˆ©ç”¨ã™ã‚‹æ™‚ã¯ãƒãƒƒãƒ”ãƒ³ã‚°ã‚„ã‚³ãƒãƒ³ãƒ‰ã«ãªã‚‹ã®ã§ã€ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã‹ã‚‰å‘¼ã³ã‚„ã™ã„å½¢ãŒè‰¯ã„ã§ã™ã­ã€‚

```vim
"autoload/charblob.vim

function charblob#encode_buffer()
  call setline(1, luaeval(
  \    'require("charblob").encode(unpack(_A))',
  \    [getline(1, '$'), &textwidth, '  ']))
endfunction

"plugin/charblob.vim

if exists('g:charblob_loaded')
  finish
endif
let g:charblob_loaded = 1

command MakeCharBlob :call charblob#encode_buffer()
```

```lua
-- lua/charblob.lua

local function charblob_bytes_iter(lines)
  local init_s = {
    next_line_idx = 1,
    next_byte_idx = 1,
    lines = lines,
  }
  local function next(s, _)
    if lines[s.next_line_idx] == nil then
      return nil
    end
    if s.next_byte_idx > #(lines[s.next_line_idx]) then
      s.next_line_idx = s.next_line_idx + 1
      s.next_byte_idx = 1
      return ('\n'):byte()
    end
    local ret = lines[s.next_line_idx]:byte(s.next_byte_idx)
    if ret == ('\n'):byte() then
      ret = 0  -- See :h NL-used-for-NUL.
    end
    s.next_byte_idx = s.next_byte_idx + 1
    return ret
  end
  return next, init_s, nil
end

local function charblob_encode(lines, textwidth, indent)
  local ret = {
    'const unsigned char blob[] = {',
    indent,
  }
  for byte in charblob_bytes_iter(lines) do
    --                .- space + number (width 3) + comma
    if #(ret[#ret]) + 5 > textwidth then
      ret[#ret + 1] = indent
    else
      ret[#ret] = ret[#ret] .. ' '
    end
    ret[#ret] = ret[#ret] .. (('%3u,'):format(byte))
  end
  ret[#ret + 1] = '};'
  return ret
end

return {
  bytes_iter = charblob_bytes_iter,
  encode = charblob_encode,
}
```
