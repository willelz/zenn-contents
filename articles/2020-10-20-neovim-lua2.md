---
title: "NeovimのためのLua入門"
emoji: "🎑"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Neovim","Lua"]
published: false
---

## はじめに
今回は`Lua.txt`を見ていきます

## どうやって読み込むのか
前回はバッファやコマンドランモードからLuaを直接実行していました。
`runtimepath`内の`lua`ディレクトリ内にファイルを置くと、Luaの`require`から読み込めるようになります。
`plugin/hoge.vim`等の`.vim`ファイルと違い、パスが通るだけで自動で読み込まれません。
そのため、`init.vim`等のどこかしらでLuaを呼ぶ必要があります。

```lua
-- lua/hi.lua

local hi = {}                                                                                                         
hi.str = 'hi'                                                                                                         
return hi

--

:lua print(require('hi").str)
"hi
```

`lua/hello/init.lua`のようにディレクトリを作るとディレクトリ名で`require`できます。
プラグインを作る場合はこちらが一般的です。

```lua
-- lua/hello/init.lua

local hello = {}
hello.str = 'hello'

return hello

--

:lua print(require('hello').str) 
"hello
```

## Luaプラグイン例
`:h lua-require-example`のプラグイン例を見てみます。
`~/.config/nvim`内等のパスの通ったところに配置すると手元で動かすことができます。

charblob.luaはLuaで完結しているので参考までに、注目して欲しいのはcharblob.vimです。
この例では普通のvimプラグインのようにVim scriptからLuaの関数を呼ぶ形になっています。
関数の提供方法を工夫すればautoloadやpluginディレクトリは必須ではありません。
しかし、LuaだLuaだと言っても利用する時はマッピングやコマンドになるので、コマンドラインモードから呼びやすい形が良いですね。

```vim
"autoload/charblob.vim

function charblob#encode_buffer()
  call setline(1, luaeval(
  \    'require("charblob").encode(unpack(_A))',
  \    [getline(1, '$'), &textwidth, '  ']))
endfunction

"plugin/charblob.vim

if exists('g:charblob_loaded')
  finish
endif
let g:charblob_loaded = 1

command MakeCharBlob :call charblob#encode_buffer()
```

```lua
-- lua/charblob.lua

local function charblob_bytes_iter(lines)
  local init_s = {
    next_line_idx = 1,
    next_byte_idx = 1,
    lines = lines,
  }
  local function next(s, _)
    if lines[s.next_line_idx] == nil then
      return nil
    end
    if s.next_byte_idx > #(lines[s.next_line_idx]) then
      s.next_line_idx = s.next_line_idx + 1
      s.next_byte_idx = 1
      return ('\n'):byte()
    end
    local ret = lines[s.next_line_idx]:byte(s.next_byte_idx)
    if ret == ('\n'):byte() then
      ret = 0  -- See :h NL-used-for-NUL.
    end
    s.next_byte_idx = s.next_byte_idx + 1
    return ret
  end
  return next, init_s, nil
end

local function charblob_encode(lines, textwidth, indent)
  local ret = {
    'const unsigned char blob[] = {',
    indent,
  }
  for byte in charblob_bytes_iter(lines) do
    --                .- space + number (width 3) + comma
    if #(ret[#ret]) + 5 > textwidth then
      ret[#ret + 1] = indent
    else
      ret[#ret] = ret[#ret] .. ' '
    end
    ret[#ret] = ret[#ret] .. (('%3u,'):format(byte))
  end
  ret[#ret + 1] = '};'
  return ret
end

return {
  bytes_iter = charblob_bytes_iter,
  encode = charblob_encode,
}
```
